#include "quickMaffs.nxc"
#include "vectors.nxc"
#include "MonteCarlo.nxc"
#include "map.nxc"
#include "vectorQueue.nxc"
#define START_X 2
#define START_Y 2
#define START_HEADING 0
#define VECTORS_TO_SCHEDUEL 3
timeStep timeStepArray[2];
void initiateTimeStep();
void firstMove(int startx, int starty, int endx, int endy, vec2 &inputArray[],int arraySize);
void nextMove(sensorReading currentSensorReading,vec2 &inputArray[], int arraySize);
void expandPath();
int schedulePartOfPath(vec2 &inputArray[], int arraySize);
void newTimeStep(sensorReading currentSensorReading);

void initiateTimeStep(){
	timeStep timeStep0;
	state probState;
	probState.x = START_X;
	probState.y = START_Y;
	probState.heading = START_HEADING;
	probState.probability = 1;
	int i;
	for(i=0;i<SAMPLE_SIZE;i++){
		timeStep0.probStates[i] = probState;
	}
	vec2 vec;
	vec.x=0;
	vec.y=0;
	sensorReading sensorReading0;
	sensorReading0.vector = vec;
	sensorReading.odometryHeading = START_HEADING;
	timeStep0.sensor = sensorReading0 ;
	timeStepArray[1] = timeStep0;

}
void firstMove(int startx, int starty, int endx, int endy, vec2 &inputArray[], int arraySize){
	//findRoute(startx,starty,endx,endy);
	schedulePartOfPath(inputArray, arraySize);
}
void nextMove(sensorReading currentSensorReading,vec2 &inputArray[], int arraySize){
	newTimeStep(currentSensorReading);
	expandPath();
	schedulePartOfPath(inputArray, arraySize);
}
task main(){

}
void expandPath(){
	state bestState = findBestState(timeStepArray[1]);
	//findRoute(bestState.x,bestState.y,path[pathPLace].x,path[pathPlace].y);
	

}
int schedulePartOfPath(vec2 &inputArray[], int arraySize){
	int i;
	int odometryHeading= findBestState(timeStepArray[1]).heading;
	vec2 commandVec;
	commandVec.x =0;
	commandVec.y =0;
	for(i=0;i<VECTORS_TO_SCHEDUEL;i++){
		//currentVector = path[pathPLace];
		//nextVector = path[pathPLace--];
		//enqueueVector(vectorMinus(nextVector,currentVector),inputArray,arraySize++);
		//commandVec =vectorPlus(vectorMinus(nextVector,currentVector,commandVec);
		if(currentVector.x > nextVector){
			odometryHeading = odometryHeading + vectorAngleBetween(currentVector, nextVector) + 180;
		}else odometryHeading = odometryHeading + vectorAngleBetween(currentVector, nextVector);
		
		//pathPLace--;
	}
	timeStepArray[1].sensorReading.vector = commandVec;
	timeStepArray[0].sensorReading.odometryHeading = odometryHeading;
	return arraySize;
}

void newTimeStep(sensorReading currentSensorReading){
	timeStepArray[0] = timeStepArray[1];
	timeStep currentTimeStep =	monteCarlo(currentSensorReading,timeStepArray[0]);
	timeStepArray[1] = currentTimeStep;
}