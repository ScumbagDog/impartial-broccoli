#include "quickMaffs.nxc"
#include "vectors.nxc"
#include "map.nxc"
#define SAMPLE_SIZE  100 
#define SENSOR_HEADING 0
#define SENSOR_X 0
#define SENSOR_Y  0
#define ULTAR_SONIC_MAX 155
#define NOISE_REDUCTION_1 1
#define NOISE_REDUCTION_2 0
#define NOISE_REDUCTION_3 1
#define NOISE_REDUCTION_4 0
#define ZHIT 0.82588
//#define ZSHORT 0.00036693 not used
#define ZMAX 0.17325
#define ZRAND 0.00050299
#define OHIT 8.4662
//#define LAMBDA_SHORT 0.0183 not used
#define DRAW_PROB 1000


struct sensorReading{
 vec2 vector;
 byte ultraSonic[];
 int ultraSonicHeading[];
 int heading;
 int odometryHeading;
};


struct state{
 int x;
 int y;
 int heading;
 float probability;
};

struct timeStep{
 state states[SAMPLE_SIZE];
 state probStates[SAMPLE_SIZE];
 sensorReading sensor;
 float maxProbability;
};

timeStep timeStep0;
timeStep timeStep1;


void monteCarlo(sensorReading sensor);
state sampleMotionModel(sensorReading sensor, state previousState, sensorReading previousSensorReading);
state sensorMotionModel(sensorReading sensor,state previousState, sensorReading previousSensorReading);
float sample(float b);
float probabilityTriangular(float a, float b);
float likelihoodFinderModel(sensorReading sensor, state newState);
float distanceNearestObject(int x, int y);
float calculateMaxProb(sensorReading sensor);

void monteCarlo(sensorReading sensor)
{
  timeStep1.sensor = sensor;
  int i;
  for( i=0;i<SAMPLE_SIZE ;i++){
        timeStep1.probStates[i]= sampleMotionModel(sensor,timeStep0.probStates[i],timeStep0.sensor);

  }
  int tempDrawCount=0;
  timeStep1.maxProbability = calculateMaxProb(sensor);
  while(tempDrawCount < SAMPLE_SIZE){
  for(i=0;i<SAMPLE_SIZE ;i++){
	 if(timeStep1.probStates[i].probability*DRAW_PROB>=(Random(timeStep1.maxProbability*DRAW_PROB))){
	    timeStep1.states[tempDrawCount]=timeStep1.probStates[i];
		tempDrawCount++;
	 }
  }
  }
}

state sampleMotionModel(sensorReading sensor, state previousState, sensorReading previousSensorReading){
 
      state newState;
	  newState = sensorMotionModel(sensor, previousState, previousSensorReading);
      newState.probability = likelihoodFinderModel(sensor,newState);
      return newState;
}
float calculateMaxProb(sensorReading sensor){
	float maxProbability = 100000000.0;
	int i;
	int arrayLength = ArrayLen(sensor.ultraSonic);
	for (i=0; i<arrayLength;i++){
		if(sensor.ultraSonic[i]<ULTAR_SONIC_MAX){
			maxProbability = maxProbability*(ZHIT*probabilityTriangular(0,pow(OHIT,2))+ZRAND/ZMAX);
		}

	
	}
	return maxProbability;
}

state sensorMotionModel(sensorReading sensor, state previousState, sensorReading previousSensorReading){
	  float previousOdometryHeading = (previousSensorReading.odometryHeading * 2 * PI)/360;
	  float currentOdomentryHeading = (sensor.odometryHeading *2 * PI)/360;
	  
      float rotation1 = atan2(sensor.vector.y-previousSensorReading.vector.y,sensor.vector.x-previousSensorReading.vector.x)-previousOdometryHeading;
      float trans = sqrt(pow(previousSensorReading.vector.x-sensor.vector.x,2)+pow(previousSensorReading.vector.y-sensor.vector.y,2));
      float rotation2 = currentOdomentryHeading-previousOdometryHeading-rotation1;
	  state newState;
	  bool done = false ;
      while(!done){
      float rotation1Updated = rotation1 - sample(NOISE_REDUCTION_1*rotation1+NOISE_REDUCTION_2*trans);
      float transUpdated = trans-sample(NOISE_REDUCTION_3*trans+NOISE_REDUCTION_4*(rotation1+rotation2));
      float rotation2Updated = rotation2 - sample(NOISE_REDUCTION_1*rotation2+NOISE_REDUCTION_2*trans);
      
     
      newState.x = trunc(previousState.x+transUpdated*cos(previousOdometryHeading+rotation1Updated)+0.5);
      newState.y = trunc(previousState.y+transUpdated*sin(previousOdometryHeading+rotation1Updated)+0.5);
      newState.heading = ((previousOdometryHeading + rotation1Updated + rotation2Updated)/ (2 * PI))  *360;
	  unsigned short index = coordToLstIndex(newState.x,newState.y);
	  if(index != -1  && isValid(index)){
		done = true ;
	  }
	 }
      return newState;
}

/*float sample(float b){
     return b*(Random(2)-1)*(Random(2)-1);

}*/
float sample(float b){
	float temp = Random(99);
	float temp2 = Random(99);
     return b*((Random(2)-temp/100.00)*(Random(2)-temp2/100.00));

}/*
float sample(float b){
	float sum =0;
	int i;
	for(i=0;i<12;i++){
		sum = sum + Random(2)-1;
	}
	
     return b/6*sum;

}*/



float probabilityTriangular(float a, float b){
      if(a>sqrt(6*b)){
        return 0;
      }else return (sqrt(6*b)-a)/(6*b);
}


float likelihoodFinderModel(sensorReading sensor, state newState){
      float probability =100000000.0;
	  int i=0;
	  int arrayLength = ArrayLen(sensor.ultraSonic);
	  /*ClearScreen();
			Wait(2000);
			NumOut(0,LCD_LINE1,i);
			NumOut(0,LCD_LINE2,newState.x);
			NumOut(0,LCD_LINE3,newState.y);
			Wait(10000);*/
	  for (i=0; i<arrayLength;i++){
			if(sensor.ultraSonic[i]<ULTAR_SONIC_MAX){
			float robotHeading = (sensor.heading * 2 * PI)/360;
			float sonicHeading = (+sensor.ultraSonicHeading[i] *2 * PI)/360;
			float sonicReading = sensor.ultraSonic[i]/GRID_FIELD_WIDTH+1;
			
			int sensorXt = trunc((newState.x+ SENSOR_X * cos(robotHeading)-SENSOR_Y*sin(robotHeading)+sonicReading*cos(robotHeading+sonicHeading))+0.5);
			int sensorYt = trunc((newState.y+ SENSOR_Y * cos(robotHeading)+SENSOR_X*sin(robotHeading)+sonicReading*sin(robotHeading+sonicHeading))+0.5);
			vec2 vec;
			vec.x = sensorXt;
			vec.y = sensorYt;
			float dist2 = findDistToObject(vec);
			probability=probability*(ZHIT*probabilityTriangular(pow(dist2,2),pow(OHIT,2))+ZRAND/ZMAX);
			/*ClearScreen();
			Wait(2000);
			NumOut(0,LCD_LINE1,i);
			NumOut(0,LCD_LINE2,sensorXt);
			NumOut(0,LCD_LINE3,sensorYt);
			NumOut(0,LCD_LINE4,dist2);
			NumOut(0,LCD_LINE5,probability);
			Wait(10000);*/
		 }
	  }
	  return probability;

}
/*
x =2
y =10
h =90
0 =
1 =1 x=1 y=10
2 =0  x=2 y=0
3 =
4 =1  x=1 y=10
5 =1  x=1  y=10
p =9951

*/


/*
state findBestState(timeStep currentTimeStep){
	state bestState;
	bestState.x = 0;
	bestState.y = 0;
	bestState.heading = 0;
	int i;
	int arrayLength = currentTimeStep.drawCount;
	for(i=0;i<arrayLength;i++){
		
		bestState.x = bestState.x + currentTimeStep.states[i].x;
		bestState.y = bestState.y + currentTimeStep.states[i].y;
		bestState.heading = bestState.heading + currentTimeStep.states[i].heading;
		
	}
	bestState.x = bestState.x/i;
	bestState.y = bestState.y/i;
	bestState.heading = bestState.heading/i;
	
	return bestState;
}*/

state findBestState(){
	state bestState;
	bestState.probability = 0;
	int i;
	int arrayLength = ArrayLen(timeStep1.states);
	for(i=0;i<arrayLength;i++){
		if(timeStep1.states[i].probability > bestState.probability){
			bestState = timeStep1.states[i];
		}
		
	}
	return bestState;
}




















float motionModelProbability(sensorReading sensor,state newState, state previousState, sensorReading previousSensorReading){
      float rotation1 = atan2(sensor.vector.y-previousSensorReading.vector.y,sensor.vector.x-previousSensorReading.vector.x)-previousSensorReading.heading;
      float trans = sqrt(pow(previousSensorReading.vector.x-sensor.vector.x,2)+pow(previousSensorReading.vector.y-sensor.vector.y,2));
      float rotation2 = sensor.heading-previousSensorReading.heading-rotation1;


      float rotation1Odometry = atan2(newState.y-previousState.y, newState.x-previousState.x)-previousState.heading;
      float transOdometry = sqrt(pow(previousState.x-newState.x,2)+pow(previousState.y-newState.y,2));
      float rotation2Odometry = newState.heading-previousState.heading-rotation1;
      
      float prob1 = probabilityTriangular(rotation1-rotation1Odometry,NOISE_REDUCTION_1*rotation1Odometry+NOISE_REDUCTION_2*transOdometry);
      float prob2 = probabilityTriangular(trans-transOdometry,NOISE_REDUCTION_3*transOdometry+NOISE_REDUCTION_4*(rotation1Odometry+rotation2Odometry));
      float prob3 = probabilityTriangular(rotation2-rotation2Odometry,NOISE_REDUCTION_1*rotation2Odometry+NOISE_REDUCTION_2*transOdometry);

      return prob1*prob2*prob3;
}

/*
void learnParameters(float &Parameters[],byte &SensorReadings[],int SensorReadingsLength,byte &realReadings[]){
     int i;
	 float n,OHIT;
	 OHIT = calculateOHIT(SensorReadings,SensorReadingsLength,realReadings);
	 for(i=0;i<SensorReadingsLength;i++){
	    n = pow(phit()+Pshort+Pmax+Prand,-1)
	 }
	 
     

}

float phit(byte sensorReading, byte realReading, float OHIT){
     if(0=<sensorReading<= SENSOR_MAX){
	    int i;
		float n=0;
		
		 pow(EULER,-1/4*(pow(realReading,3)/3-4*pow(realReading,2)+4*realReading))/(sqrt(2*PI*pow(OHIT,2)));  
		
		
		
		return 
	 }
	 return 0;
}

float calculateBigN(byte sensorReading, byte realReading, float OHIT){
     float bigDiversion = -0.5*pow(sensorReading-realReading,2)/pow(OHIT,2);
     return 1/sqrt(2*PI*pow(OHIT,2))*pow(EULER,bigDiversion);
}

float calculateOHIT(byte &SensorReadings[],int SensorReadingsLength,byte &realReadings[]){
     int i, hitReadings =0;
	 float sum =0;
	 for(i=0;i<SensorReadingsLength;i++){
	    if(0=<sensorReadings[i]<= SENSOR_MAX){
		  sum +=pow(sensorReadings[i]-realReadings[i],2);
		  hitReadings++;
		}
		return sqrt(1/hitReadings*sum);
	 }
}
*/


