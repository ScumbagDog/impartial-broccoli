#define ROOM_LENGTH 475
#define ROOM_WIDTH 345
#define NUM_ACTIONS 4
#define GRID_FIELD_WIDTH 10
#define MAP_LENGTH 30
#define MAP_WIDTH 30
#define UNDEFINED -1
#define T_MAX MAP_LENGTH * MAP_WIDTH
#define NODE_TO_NODE_COST 1
#define NO_LST 0
#define OPEN_LST 1
#define OPEN_LST 1


enum FieldValue {unoccupied, table, wall};

struct gridCoord{
  float x;
  float y;
};

struct graphNode {
  unsigned short c;
  unsigned short t;
  byte whichLst;
  unsigned short parentInd;
};

void fillMap();
bool findRoute(gridCoord &path[], unsigned short &pathLength, unsigned short startX, unsigned short startY, unsigned short goalX, unsigned short goalY);
bool isValid(unsigned short index);
void initializeNodeLst(graphNode &nodeLst[]);
unsigned short findLowestT(graphNode &nodeLst[]);
bool coordEquals(unsigned short index1, unsigned short index2);
unsigned short coordToLstIndex(unsigned short x, unsigned short y);
unsigned short calcX(unsigned short index);
unsigned short calcY(unsigned short index);
bool visitSucc(graphNode &successor, unsigned short succInd, unsigned short succInd_whichLst, unsigned short succInd_t, unsigned short currInd, unsigned short currInd_c, unsigned short goalInd);
unsigned short calcManhattanDist(unsigned short index1, unsigned short index2);
gridCoord makeVec(unsigned short index);
float findDistToObject(gridCoord coord);
bool outOfBounds(int index, bool isX);
float calcEuclideanDist(float xFrom, float yFrom, float xTo, float yTo);
float min(float val1, float val2);

FieldValue map[MAP_LENGTH][MAP_WIDTH];
const byte noLst = 1, openLst = 2, closedLst = 3;

void fillMap(){
  for(int x = 0; x < MAP_LENGTH; x++) {
    for(int y = 0; y < MAP_WIDTH; y++) {
      if (x == 0 || x == MAP_LENGTH - 1 || y == 0 || y == MAP_WIDTH - 1) {
        map[x][y] = wall;
      } else {
        map[x][y] = unoccupied; 
      }
    }
  }
}

//------------------------------ A* search ------------------------------
bool findRoute(gridCoord &path[], unsigned short &pathLength, unsigned short startX, unsigned short startY, unsigned short goalX, unsigned short goalY) {
  graphNode nodeLst[MAP_LENGTH * MAP_WIDTH];
  graphNode succ;
  unsigned short startInd = coordToLstIndex(startX, startY), goalInd = coordToLstIndex(goalX, goalY), currInd, succInd;
  unsigned short openLstLength = 0, lowestT, iLowestT = UNDEFINED;
  bool openLstIsEmpty = false, addToOpenLst;

  pathLength = 0;

  if(isValid(startInd) && isValid(goalInd)) {
    initializeNodeLst(nodeLst);

    //---------- Add startInd to openLst ----------
    nodeLst[startInd].t = 0;
    nodeLst[startInd].whichLst = openLst;
    openLstLength++;

    //---------- Begin search ----------
    until (openLstIsEmpty) {
      //---------- Find node with lowest t-value ----------
      lowestT = T_MAX;

      for (int i = 0; i < MAP_LENGTH * MAP_WIDTH; i++) {
        if (nodeLst[i].whichLst == openLst && nodeLst[i].t < lowestT) {
          lowestT = nodeLst[i].t;
          currInd = i;
        }
      }

      nodeLst[currInd].whichLst = closedLst;
      openLstLength--;

      if (coordEquals(currInd, goalInd)) {
        break;
      }

      //---------- Visit north successor ----------
      succInd = coordToLstIndex(calcX(currInd), calcY(currInd) + 1);
      addToOpenLst = visitSucc(succ, succInd, nodeLst[succInd].whichLst, nodeLst[succInd].t, currInd, nodeLst[currInd].c, goalInd);

      if(addToOpenLst) {
        nodeLst[succInd] = succ;
        nodeLst[succInd].whichLst = openLst;
        openLstLength++;
      }
      
      //---------- Visit east successor ----------
      succInd = coordToLstIndex(calcX(currInd) + 1, calcY(currInd));
      addToOpenLst = visitSucc(succ, succInd, nodeLst[succInd].whichLst, nodeLst[succInd].t, currInd, nodeLst[currInd].c, goalInd);

      if(addToOpenLst) {
        nodeLst[succInd] = succ;
        nodeLst[succInd].whichLst = openLst;
        openLstLength++;
      }

      //---------- Visit south successor ----------
      succInd = coordToLstIndex(calcX(currInd), calcY(currInd) - 1);
      addToOpenLst = visitSucc(succ, succInd, nodeLst[succInd].whichLst, nodeLst[succInd].t, currInd, nodeLst[currInd].c, goalInd);

      if(addToOpenLst) {
        nodeLst[succInd] = succ;
        nodeLst[succInd].whichLst = openLst;
        openLstLength++;
      }

      //---------- Visit west successor ----------
      succInd = coordToLstIndex(calcX(currInd) - 1, calcY(currInd));
      addToOpenLst = visitSucc(succ, succInd, nodeLst[succInd].whichLst, nodeLst[succInd].t, currInd, nodeLst[currInd].c, goalInd);

      if(addToOpenLst) {
        nodeLst[succInd] = succ;
        nodeLst[succInd].whichLst = openLst;
        openLstLength++;
      }

      openLstIsEmpty = openLstLength <= 0;
    }

    if (nodeLst[goalInd].whichLst == closedLst){
      while(currInd != startInd){
        path[pathLength] = makeVec(currInd);
        pathLength++;
        currInd = nodeLst[currInd].parentInd;
      }
    }
  }
  
  return pathLength != 0;
}

bool isValid(unsigned short index) {
  return 0 <= index && index < MAP_LENGTH * MAP_WIDTH && map[calcX(index)][calcY(index)] == unoccupied; 
}

void initializeNodeLst(graphNode &nodeLst[]) {
  for (int i = 0; i < MAP_LENGTH * MAP_WIDTH; i++) {
    nodeLst[i].c = 0;
    nodeLst[i].t = T_MAX;
    nodeLst[i].whichLst = noLst;
    nodeLst[i].parentInd = UNDEFINED;
  }
}

unsigned short findLowestT(graphNode &nodeLst[]) {
  unsigned short lowestT = T_MAX, iLowestT = UNDEFINED;

  for (int i = 0; i < MAP_LENGTH * MAP_WIDTH; i++) {
    if (nodeLst[i].whichLst == openLst && nodeLst[i].t < lowestT) {
      lowestT = nodeLst[i].t;
      iLowestT = i;
    }
  } 

  return iLowestT;
}

bool coordEquals(unsigned short index1, unsigned short index2) {
  return index1 == index2;
}

unsigned short coordToLstIndex(unsigned short x, unsigned short y) {
  if (0 <= x && x < MAP_LENGTH && 0 <= y && y < MAP_WIDTH) {
    return x * MAP_WIDTH + y;
  } else {
    return UNDEFINED;
  }
}

unsigned short calcX(unsigned short index){
  return index / MAP_WIDTH;
}

unsigned short calcY(unsigned short index){
  return index % MAP_WIDTH;
}

bool visitSucc(graphNode &successor, unsigned short succInd, unsigned short succInd_whichLst, unsigned short succInd_t, unsigned short currInd, unsigned short currInd_c, unsigned short goalInd) {
  if (isValid(succInd) && succInd_whichLst != closedLst) {
    successor.c = currInd_c + NODE_TO_NODE_COST;
    successor.t = calcManhattanDist(succInd, goalInd) + successor.c;
    successor.parentInd = currInd;
    
    if (succInd_whichLst == noLst || (succInd_whichLst == openLst && successor.t < succInd_t)) {
      return true;
    }
  }

  return false;
}

unsigned short calcManhattanDist(unsigned short index1, unsigned short index2) {
  return abs(calcX(index1) - calcX(index2)) + abs(calcY(index1) - calcY(index2));
}

gridCoord makeVec(unsigned short index) {
  gridCoord vec;

  vec.x = calcX(index);
  vec.y = calcY(index);

  return vec;
}

//------------------------------ Distance to nearest object ------------------------------
float findDistToObject(gridCoord coord) {
  int xInit, xLimit, yInit, yLimit, layer = 0;
  float shortestDist = SHRT_MAX, tempDist;
  bool objectFound = false;

  until (objectFound){
    xInit = coord.x - layer;
    xLimit = coord.x + layer;

    yInit = coord.y - layer;
    yLimit = coord.y + layer;

    for(int x = xInit; x <= xLimit; x++) {
      for(int y = yInit; y <= yLimit; ) {
        if (!outOfBounds(x, true) && !outOfBounds(y, false)) {
          if (map[x][y] == table || map[x][y] == wall) {
            tempDist = calcEuclideanDist(coord.x, coord.y, x, y);
            shortestDist = min(tempDist, shortestDist);
            objectFound = true;
          }

          if(x == xInit || x == xLimit) {
            y++;
          } else {
            y += 2 * layer;
          }
        } 
      }
    }

    layer++;
  }

  return shortestDist;
}

bool outOfBounds(int index, bool isX) {
  if (isX) {
    return index < 0 || index >= MAP_LENGTH;
  } else {
    return index < 0 || index >= MAP_WIDTH;
  }
}

float calcEuclideanDist(float xFrom, float yFrom, float xTo, float yTo) {
  return sqrt(pow(abs(xFrom - xTo), 2) + pow(abs(yFrom - yTo), 2));
}

float min(float val1, float val2) {
  if (val1 < val2) {
    return val1;
  } else {
    return val2;
  }
}

task main() {
  gridCoord coord;
  gridCoord path[MAP_LENGTH * MAP_WIDTH];
  unsigned short pathLength;
  float shortestDist;

  coord.x = 4;
  coord.y = 3;
  
  fillMap();
  //shortestDist = findDistToObject(coord);

  findRoute(path, pathLength, 1, 1, 5, 5);

  for(int i = pathLength - 1; i >= 0; i--){
    NumOut(0, LCD_LINE1, path[i].x);
    NumOut(0, LCD_LINE2, path[i].y);
    Wait(1000);
  }
}