#define ROOM_LENGTH 475
#define ROOM_WIDTH 345
#define NUM_ACTIONS 4
#define GRID_FIELD_WIDTH 20
#define MAP_LENGTH (475 / 20) + 1
#define MAP_WIDTH (345 / 20) + 1
#define UNDEFINED -1
#define T_MAX MAP_LENGTH * MAP_WIDTH
#define NODE_TO_NODE_COST 1

enum FieldValue {unoccupied, table, wall};

struct lst {
  bool items[MAP_LENGTH][MAP_WIDTH];
  int length;
};

struct gridCoord {
  int x;
  int y;
};

struct path {
  gridCoord coordLst[MAP_LENGTH * MAP_WIDTH];
  int length;
};

struct graphNode {
  int h;
  int c;
  int t;
  gridCoord parent;
};

void fillMap();
bool aStarSearch(path pathToGoal, int startX, int startY, int goalX, int goalY);
gridCoord makeCoord(int x, int y);
bool isValid(gridCoord coord);
void initializeLists(lst &openLst, lst &closedLst, graphNode &nodeLst[]);
void initializeOpenOrClosedLst(lst openOrClosedLst);
void initializeNodeLst(graphNode &nodeLst[]);
void addToLst(gridCoord coord, lst &openOrClosedLst);
void findGoal(lst &openLst, lst &closedLst, graphNode &nodeLst[], gridCoord goalCoord);
path generatePath(gridCoord goalCoord, gridCoord startCoord, graphNode &nodeLst[]);
gridCoord findAndRemoweLowestT(lst &openLst, graphNode &nodeLst[]);
bool coordEquals(gridCoord coord1, gridCoord coord2);
void expandNode(gridCoord currCoord, gridCoord goalCoord, lst &openLst, lst &closedLst, graphNode &nodeLst[]);
void generateChildren(gridCoord &children[], gridCoord parent);
void visitSucessor(gridCoord child, gridCoord parent, gridCoord goalCoord, lst &openLst, lst &closedLst, graphNode &nodeLst[]);
bool isInLst(gridCoord coord, lst openOrClosedLst);
int calcManhattanDist(gridCoord currCoord, gridCoord goalCoord);
bool hasLowerT(gridCoord coord, int tSucc, graphNode &nodeLst[]);
void addToNodeLst(gridCoord coord, int hSucc, int cSucc, int tSucc, gridCoord parent, graphNode &nodeLst[]);
int toLstIndex(int x, int y);


FieldValue map[MAP_LENGTH][MAP_WIDTH];

task main() {
  path pathToGoal;
  fillMap();
  aStarSearch(pathToGoal, 0, 0, 5, 5);
  //NumOut(0, LCD_LINE4, 1);
}

void fillMap(){
  for(int x = 0; x < MAP_LENGTH; x++) {
    for(int y = 0; y < MAP_WIDTH; y++) {
      map[x][y] = unoccupied;
    }
  }
}

bool aStarSearch(path pathToGoal, int startX, int startY, int goalX, int goalY) {
  lst openLst, closedLst;
  graphNode nodeLst[MAP_LENGTH * MAP_WIDTH];
  gridCoord startCoord = makeCoord(startX, startY), goalCoord = makeCoord(goalX, goalY);

  pathToGoal.length = 0;

  if(isValid(startCoord) && isValid(goalCoord)) {
    initializeLists(openLst, closedLst, nodeLst);

    addToLst(startCoord, openLst);
  
    //findGoal(openLst, closedLst, nodeLst, goalCoord);

    /*if(isInLst(goalCoord, closedLst)) {
      pathToGoal = generatePath(startCoord, goalCoord, nodeLst);
    }*/
  }

  /*return pathToGoal.length == 0;*/
  return true;
}

gridCoord makeCoord(int x, int y) {
  gridCoord coord;
  
  coord.x = x;
  coord.y = y;

  return coord;
}

void initializeLists(lst &openLst, lst &closedLst, graphNode &nodeLst[]) {
  initializeOpenOrClosedLst(openLst);
  initializeOpenOrClosedLst(closedLst);
  initializeNodeLst(nodeLst);
}

void initializeOpenOrClosedLst(lst openOrClosedLst) {
  openOrClosedLst.length = 0;

  for (int x = 0; x < MAP_LENGTH; x++) {
    for (int y = 0; y < MAP_WIDTH; y++) {
      openOrClosedLst.items[x][y] = false;
    }
  }
}

void initializeNodeLst(graphNode &nodeLst[]) {
  int x = 0, y = 0;
  graphNode node;
  gridCoord parent;

  for (x = 0; x < MAP_LENGTH; x++) {
    for (y = 0; y < MAP_WIDTH; y++) {
      parent.x = UNDEFINED;
      parent.y = UNDEFINED;
      node.h = 0;
      node.c = 0;
      node.t = 0;
      node.parent = parent;
      
      nodeLst[toLstIndex(x, y)] = node;
    }
  }
  NumOut(0, LCD_LINE1, x);
}

void addToLst(gridCoord coord, lst &openOrClosedLst) {
  int x = coord.x, y = coord.y;

  openOrClosedLst.items[x][y] = true;
  openOrClosedLst.length++;
}

void findGoal(lst &openLst, lst &closedLst, graphNode &nodeLst[], gridCoord goalCoord) {
  gridCoord currCoord;
  bool openLstIsEmpty = false;

  until (openLstIsEmpty) {
    currCoord = findAndRemoweLowestT(openLst, nodeLst);
    addToLst(currCoord, closedLst);

    if (coordEquals(currCoord, goalCoord)) {
      break;
    }

    expandNode(currCoord, goalCoord, openLst, closedLst, nodeLst);

    openLstIsEmpty = openLst.length > 0;
  }
}

gridCoord findAndRemoweLowestT(lst &openLst, graphNode &nodeLst[]) {
  int index, lowestT = T_MAX, xLowestT = UNDEFINED, yLowestT = UNDEFINED;

  for (int x = 0; x < MAP_LENGTH; x++) {
    for (int y = 0; y < MAP_WIDTH; y++) {
      index = toLstIndex(x, y);
      if (openLst.items[x][y] == true && nodeLst[index].t < lowestT) {
        lowestT = nodeLst[index].t;
        xLowestT = x;
        yLowestT = y;
      }
    }
  }

  openLst.items[xLowestT][yLowestT] = false;
  openLst.length--;

  return makeCoord(xLowestT, yLowestT);
}

int toLstIndex(int x, int y) {
  return x * MAP_LENGTH + y;
}

void expandNode(gridCoord currCoord, gridCoord goalCoord, lst &openLst, lst &closedLst, graphNode &nodeLst[]) {
  gridCoord children[NUM_ACTIONS];
  
  generateChildren(children, currCoord);
  
  for (int i = 0; i < NUM_ACTIONS; i++) {
    visitSucessor(children[i], currCoord, goalCoord, openLst, closedLst, nodeLst);
  }
}

void generateChildren(gridCoord &children[], gridCoord parent){
  int parentX = parent.x, parentY = parent.y;

  children[0] = makeCoord(parentX, parentY - 1);
  children[1] = makeCoord(parentX, parentY + 1);
  children[2] = makeCoord(parentX - 1, parentY);
  children[3] = makeCoord(parentX + 1, parentY);
}

void visitSucessor(gridCoord child, gridCoord parent, gridCoord goalCoord, lst &openLst, lst &closedLst, graphNode &nodeLst[]) {
  int hSucc = 0, cSucc = 0, tSucc = 0;

  if (isValid(child)) {
    if (!isInLst(child, closedLst)) {
      hSucc = calcManhattanDist(child, goalCoord);
      cSucc = nodeLst[toLstIndex(parent.x, parent.y)].c + NODE_TO_NODE_COST;
      tSucc = hSucc + cSucc;
    
      if (isInLst(child, openLst) && hasLowerT(child, tSucc, nodeLst)) {
        addToNodeLst(child, hSucc, cSucc, tSucc, parent, nodeLst);
        addToLst(child, openLst);
      }
    }
  }
}

bool isValid(gridCoord coord) {
  int x = coord.x, int y = coord.y;

  return (0 <= x && x < MAP_LENGTH) && (0 <= y && y < MAP_WIDTH) && map[x][y] == unoccupied; 
}

bool isInLst(gridCoord coord, lst &openOrClosedLst) {
  return openOrClosedLst.items[coord.x][coord.y];
}

int calcManhattanDist(gridCoord currCoord, gridCoord goalCoord) {
  return abs(currCoord.x - goalCoord.x) + abs(currCoord.y - goalCoord.y);
}

bool hasLowerT(gridCoord coord, int tSucc, graphNode &nodeLst[]) {
  return tSucc < nodeLst[toLstIndex(coord.x, coord.y)];
}

void addToNodeLst(gridCoord coord, int hSucc, int cSucc, int tSucc, gridCoord parent, graphNode &nodeLst[]) {
  int index = toLstIndex(coord.x, coord.y);

  nodeLst[index].h = hSucc;
  nodeLst[index].c = cSucc;
  nodeLst[index].t = tSucc;
  nodeLst[index].parent = parent;
}

path generatePath(gridCoord goalCoord, gridCoord startCoord, graphNode &nodeLst[]) {
  path pathToGoal;
  gridCoord currCoord = goalCoord;
  int i = 0;
  bool pathIsComplete = false;

  pathToGoal.length = 0;

  until (pathIsComplete) {
    pathToGoal.coordLst[i] = currCoord;
    pathToGoal.length++;
    i++;
    if (coordEquals(currCoord, startCoord)) {
      pathIsComplete = true;
    } else {
      currCoord = nodeLst[toLstIndex(currCoord.x, currCoord.y)].parent;
    }
  }
  return pathToGoal;
}

bool coordEquals(gridCoord coord1, gridCoord coord2) {
  return coord1.x == coord2.x && coord1.y == coord2.y;
}
