#define ROOM_LENGTH 475
#define ROOM_WIDTH 345
#define NUM_ACTIONS 4
#define GRID_FIELD_WIDTH 20
#define MAP_LENGTH (475 / 20) + 1
#define MAP_WIDTH (345 / 20) + 1
#define UNDEFINED -1
#define T_MAX MAP_LENGTH * MAP_WIDTH
#define NODE_TO_NODE_COST 1
#define NO_LST 0
#define OPEN_LST 1
#define OPEN_LST 1


enum FieldValue {unoccupied, table, wall};

struct gridCoord {
  float x;
  float y;
};

struct path {
  gridCoord coordLst[MAP_LENGTH * MAP_WIDTH];
  int length;
};

struct graphNode {
  gridCoord coordinate;
  unsigned short h;
  unsigned short c;
  unsigned short t;
  byte whichLst;
  gridCoord parent;
};


FieldValue map[MAP_LENGTH][MAP_WIDTH];
const byte noLst = 1, openLst = 2, closedLst = 3;

void fillMap(){
  for(int x = 0; x < MAP_LENGTH; x++) {
    for(int y = 0; y < MAP_WIDTH; y++) {
      map[x][y] = unoccupied;
    }
  }
}

gridCoord makeCoord(int x, int y) {
  gridCoord coord;
  
  coord.x = x;
  coord.y = y;

  return coord;
}

bool isValid(gridCoord coord) {
  int x = coord.x, int y = coord.y;

  return (0 <= x && x < MAP_LENGTH) && (0 <= y && y < MAP_WIDTH) && map[x][y] == unoccupied; 
}

gridCoord lstIndexToCoord(int index){
  return makeCoord(index / MAP_WIDTH, index % MAP_WIDTH);
}

void initializeNodeLst(graphNode &nodeLst[]) {
  gridCoord coord;

  for (int i = 0; i < MAP_LENGTH * MAP_WIDTH; i++) {
    coord = lstIndexToCoord(i);
    nodeLst[i].coordinate = coord;
    nodeLst[i].h = 0;
    nodeLst[i].c = 0;
    nodeLst[i].t = 0;
    nodeLst[i].whichLst = noLst;
    nodeLst[i].parent.x = UNDEFINED;
    nodeLst[i].parent.y = UNDEFINED;
  }
}

int coordToLstIndex(gridCoord coord) {
  return coord.x * MAP_WIDTH + coord.y;
}

gridCoord findLowestT(graphNode &nodeLst[]) {
  int index = 0, lowestT = T_MAX, iLowestT = UNDEFINED, yLowestT = UNDEFINED;

  for (int i = 0; i < MAP_LENGTH * MAP_WIDTH; i++) {
      if (nodeLst[i].whichLst == openLst && nodeLst[i].t < lowestT) {
        lowestT = nodeLst[index].t;
        iLowestT = i;
      }
  }

  return lstIndexToCoord(iLowestT);
}

void addToOpenLst(gridCoord coord, graphNode &nodeLst[], unsigned short &openLstLength){
  nodeLst[coordToLstIndex(coord)].whichLst = openLst;
  openLstLength++;
}

bool coordEquals(gridCoord coord1, gridCoord coord2) {
  return coord1.x == coord2.x && coord1.y == coord2.y;
}

unsigned short calcDist(gridCoord currCoord, gridCoord goalCoord) {
  return abs(currCoord.x - goalCoord.x) + abs(currCoord.y - goalCoord.y);
}

bool aStarSearch(path pathToGoal, int startX, int startY, int goalX, int goalY) {
  graphNode nodeLst[MAP_LENGTH * MAP_WIDTH];
  graphNode successor;
  gridCoord startCoord = makeCoord(startX, startY), goalCoord = makeCoord(goalX, goalY), currCoord;
  unsigned short openLstLength = 0, hSucc, cSucc, tSucc;
  bool openLstIsEmpty = false;

  pathToGoal.length = 0;

  if(isValid(startCoord) && isValid(goalCoord)) {
    initializeNodeLst(nodeLst);

    addToOpenLst(startCoord, nodeLst, openLstLength);
  
    //---------- Begin search ----------
    until (openLstIsEmpty) {
      currCoord = findLowestT(nodeLst);
      nodeLst[coordToLstIndex(currCoord)].whichLst = closedLst;

      if (coordEquals(currCoord, goalCoord)) {
        break;
      }

      //---------- Visit north successor ----------
      successor.coordinate.x = currCoord.x;
      successor.coordinate.y = currCoord.y + 1;
      successor.parent = currCoord;

      if (isValid(successor.coordinate)) {
        if (nodeLst[coordToLstIndex(successor.coordinate)].whichLst == closedLst) {
          break;
        }
        
        successor.h = calcDist(successor.coordinate, goalCoord);
        successor.c = nodeLst[coordToLstIndex(currCoord)].c + NODE_TO_NODE_COST;
        successor.t = successor.h + successor.c;
    
        if (nodeLst[coordToLstIndex(successor.coordinate)].whichLst == openLst && successor.t < nodeLst[coordToLstIndex(successor.coordinate)].t) {
          nodeLst[coordToLstIndex(successor.coordinate)] = successor;
          addToOpenLst(successor.coordinate, nodeLst, openLstLength);
        }
      }

      //---------- Visit east successor ----------
      successor.coordinate.x = currCoord.x + 1;
      successor.coordinate.y = currCoord.y;
      successor.parent = currCoord;

      if (isValid(successor.coordinate)) {
        if (nodeLst[coordToLstIndex(successor.coordinate)].whichLst == closedLst) {
          break;
        }
        
        successor.h = calcDist(successor.coordinate, goalCoord);
        successor.c = nodeLst[coordToLstIndex(currCoord)].c + NODE_TO_NODE_COST;
        successor.t = successor.h + successor.c;
    
        if (nodeLst[coordToLstIndex(successor.coordinate)].whichLst == openLst && successor.t < nodeLst[coordToLstIndex(successor.coordinate)].t) {
          nodeLst[coordToLstIndex(successor.coordinate)] = successor;
          addToOpenLst(successor.coordinate, nodeLst, openLstLength);
        }
      }

      //---------- Visit south successor ----------
      successor.coordinate.x = currCoord.x;
      successor.coordinate.y = currCoord.y - 1;
      successor.parent = currCoord;

      if (isValid(successor.coordinate)) {
        if (nodeLst[coordToLstIndex(successor.coordinate)].whichLst == closedLst) {
          break;
        }
        
        successor.h = calcDist(successor.coordinate, goalCoord);
        successor.c = nodeLst[coordToLstIndex(currCoord)].c + NODE_TO_NODE_COST;
        successor.t = successor.h + successor.c;
    
        if (nodeLst[coordToLstIndex(successor.coordinate)].whichLst == openLst && successor.t < nodeLst[coordToLstIndex(successor.coordinate)].t) {
          nodeLst[coordToLstIndex(successor.coordinate)] = successor;
          addToOpenLst(successor.coordinate, nodeLst, openLstLength);
        }
      }

      //---------- Visit west successor ----------
      successor.coordinate.x = currCoord.x - 1;
      successor.coordinate.y = currCoord.y;
      successor.parent = currCoord;

      if (isValid(successor.coordinate)) {
        if (nodeLst[coordToLstIndex(successor.coordinate)].whichLst == closedLst) {
          break;
        }
        
        successor.h = calcDist(successor.coordinate, goalCoord);
        successor.c = nodeLst[coordToLstIndex(currCoord)].c + NODE_TO_NODE_COST;
        successor.t = successor.h + successor.c;
    
        if (nodeLst[coordToLstIndex(successor.coordinate)].whichLst == openLst && successor.t < nodeLst[coordToLstIndex(successor.coordinate)].t) {
          nodeLst[coordToLstIndex(successor.coordinate)] = successor;
          addToOpenLst(successor.coordinate, nodeLst, openLstLength);
        }
      }

      openLstIsEmpty = openLstLength > 0;
    }

    //if(nodeLst[coordToLstIndex(goalCoord)].whichLst == closedLst) {
      //pathToGoal = generatePath(startCoord, goalCoord, nodeLst);
    //}
  }

  //return pathToGoal.length == 0;
  return true;
}

task main() {
  path pathToGoal;
  fillMap();
  aStarSearch(pathToGoal, 0, 0, 10, 10);
}