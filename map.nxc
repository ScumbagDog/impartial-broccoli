#define ROOM_LENGTH 475
#define ROOM_WIDTH 345
#define NUM_ACTIONS 4
#define GRID_FIELD_WIDTH 20
#define MAP_LENGTH 24
#define MAP_WIDTH 18
#define UNDEFINED -1
#define T_MAX MAP_LENGTH * MAP_WIDTH
#define NODE_TO_NODE_COST 1
#define NO_LST 0
#define OPEN_LST 1
#define OPEN_LST 1


enum FieldValue {unoccupied, table, wall};

struct gridCoord{
  float x;
  float y;
};

struct path {
  gridCoord vecLst[MAP_LENGTH * MAP_WIDTH];
  int length;
};

struct graphNode {
  unsigned short h;
  unsigned short c;
  unsigned short t;
  byte whichLst;
  unsigned short parentInd;
};


FieldValue map[MAP_LENGTH][MAP_WIDTH];
const byte noLst = 1, openLst = 2, closedLst = 3;

void fillMap(){
  for(int x = 0; x < MAP_LENGTH; x++) {
    for(int y = 0; y < MAP_WIDTH; y++) {
      map[x][y] = unoccupied;
    }
  }
}

unsigned short calcX(unsigned short index){
  return index / MAP_WIDTH;
}

unsigned short calcY(unsigned short index){
  return index % MAP_WIDTH;
}

bool isValid(unsigned short index) {
  return 0 <= index && index < MAP_LENGTH * MAP_WIDTH && map[calcX(index)][calcY(index)] == unoccupied; 
}

void initializeNodeLst(graphNode &nodeLst[]) {
  for (int i = 0; i < MAP_LENGTH * MAP_WIDTH; i++) {
    nodeLst[i].c = 0;
    nodeLst[i].t = 0;
    nodeLst[i].whichLst = noLst;
    nodeLst[i].parentInd = UNDEFINED;
  }
}

unsigned short coordToLstIndex(unsigned short x, unsigned short y) {
  if (0 <= x && x < MAP_LENGTH && 0 <= y && y < MAP_WIDTH) {
    return x * MAP_WIDTH + y;
  } else {
    return UNDEFINED;
  }
}

unsigned short findLowestT(graphNode &nodeLst[]) {
  unsigned short lowestT = T_MAX, iLowestT = UNDEFINED;

  for (int i = 0; i < MAP_LENGTH * MAP_WIDTH; i++) {
      if (nodeLst[i].whichLst == openLst && nodeLst[i].t < lowestT) {
        lowestT = nodeLst[i].t;
        iLowestT = i;
      }
  }

  return iLowestT;
}

void addToOpenLst(unsigned short index, graphNode &nodeLst[], unsigned short &openLstLength){
  nodeLst[index].whichLst = openLst;
  openLstLength++;
}

bool coordEquals(unsigned short index1, unsigned short index2) {
  return index1 == index2;
}

unsigned short calcDist(unsigned short index1, unsigned short index2) {
  return abs(calcX(index1) - calcX(index2)) + abs(calcY(index1) - calcY(index2));
}

void visitSuccessor(unsigned short succInd, unsigned short currInd, unsigned short goalInd, graphNode &nodeLst[], unsigned short &openLstLength){
  graphNode successor;

  if (isValid(succInd)) {
      NumOut(0, LCD_LINE1, calcX(succInd));
      NumOut(0, LCD_LINE2, calcY(succInd));
      Wait(SEC_1);
      ClearScreen();

    if (nodeLst[succInd].whichLst == closedLst) {
      return;
    }

    successor.c = nodeLst[currInd].c + NODE_TO_NODE_COST;
    successor.t = calcDist(succInd, goalInd) + successor.c;
    successor.parentInd = currInd;
    
    if (nodeLst[succInd].whichLst == noLst || (nodeLst[succInd].whichLst == openLst && successor.t < nodeLst[succInd].t)) {
      nodeLst[succInd] = successor;
      addToOpenLst(succInd, nodeLst, openLstLength);
    }
  }
}

gridCoord makeVec(unsigned short index) {
  gridCoord vec;

  vec.x = calcX(index);
  vec.y = calcY(index);

  return vec;
}

void generatePath(path &pathToGoal, unsigned short startInd, unsigned short goalInd, graphNode &nodeLst[]){
  unsigned short currInd = goalInd;
  
  while(currInd != startInd){
    pathToGoal.vecLst[currInd] = makeVec(currInd);
    pathToGoal.length++;
    currInd = nodeLst[currInd].parentInd;
  }
}

bool aStarSearch(path &pathToGoal, unsigned short startX, unsigned short startY, unsigned short goalX, unsigned short goalY) {
  graphNode nodeLst[MAP_LENGTH*MAP_WIDTH];
  graphNode successor;
  unsigned short startInd = coordToLstIndex(startX, startY), goalInd = coordToLstIndex(goalX, goalY), currInd, succInd, openLstLength = 0;
  bool openLstIsEmpty = false;
  
  pathToGoal.length = 0;

  if(isValid(startInd) && isValid(goalInd)) {
    initializeNodeLst(nodeLst);

    addToOpenLst(startInd, nodeLst, openLstLength);
  
    //---------- Begin search ----------
    until (openLstIsEmpty) {
      currInd = findLowestT(nodeLst);
      nodeLst[currInd].whichLst = closedLst;
      openLstLength--;
      
      if (coordEquals(currInd, goalInd)) {
        break;
      }

      //---------- Visit north successor ----------
      succInd = coordToLstIndex(calcX(currInd), calcY(currInd) + 1);
      visitSuccessor(succInd, currInd, goalInd, nodeLst, openLstLength);

      //---------- Visit east successor ----------
      succInd = coordToLstIndex(calcX(currInd) + 1, calcY(currInd));
      visitSuccessor(succInd, currInd, goalInd, nodeLst, openLstLength);

      //---------- Visit south successor ----------
      succInd = coordToLstIndex(calcX(currInd), calcY(currInd) - 1);
      visitSuccessor(succInd, currInd, goalInd, nodeLst, openLstLength);

      //---------- Visit west successor ----------
      succInd = coordToLstIndex(calcX(currInd) - 1, calcY(currInd));
      visitSuccessor(succInd, currInd, goalInd, nodeLst, openLstLength);

      openLstIsEmpty = openLstLength <= 0;
    }

    if(nodeLst[goalInd].whichLst == closedLst) {
      generatePath(pathToGoal, startInd, goalInd, nodeLst);
    }
  }

  return pathToGoal.length == 0;
}

task main() {
  path pathToGoal;
  fillMap();
  aStarSearch(pathToGoal, 0, 0, 10, 10);
}