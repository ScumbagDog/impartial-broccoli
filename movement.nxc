#ifndef MOVE_IS_COMPILED
#define MOVE_IS_COMPILED 1
#define WHEEL_DIAMETER 4.5
#define WHEEL_CIRCUMFERENCE WHEEL_DIAMETER * PI
#define ROBOT_WIDTH 10
#define CM_TO_VECTORUNIT 100
#define MAX_MOTORPOWER 80
#include "vectors.nxc"
#include "quickMaffs.nxc"

void move(vec2 moveVector);
void rotate(vec2 moveVector);
void driveStraight(float vectorUnitsToDrive);
float getRadiansToTurn(vec2 moveVector);
task turnWithMotorA();
task turnWithMotorB();
task releaseMotors();

vec2 currentMovementVector;
int sharedDegreesToTurn;
int releaseMotorCallCount;
bool isMovingForward;

mutex moveVectorMutex;
mutex sharedDegreeMutex;
mutex rotationMutex;
mutex countMutex;

void movement(){
  Acquire(moveVectorMutex);
  if(!floatEquals(vectorMag(currentMovementVector), 0)){
    //If current vector isn't a nul-vektor
    vec2 moveVectorSnapshot = currentMovementVector;
    Release(moveVectorMutex);
    move(moveVectorSnapshot);
  }
  else{
    Release(moveVectorMutex);
  }
}

void move(vec2 moveVector){
  if(!floatEquals(moveVector.x, 0) || sign(moveVector.y) < 0){
    rotate(moveVector);
  }
  driveStraight(vectorMag(moveVector));
}

void rotate(vec2 moveVector){
  //do some code here that actually turns the wheels based on getRadiansToTurn
  float radiansToTurnRobot = getRadiansToTurn(moveVector);
  float distanceToTurnWheels = radiansToTurnRobot * (ROBOT_WIDTH / 2); //Robot width is the length of its radius, which is the length of one radian.
  float radiansToTurnWheels = distanceToTurnWheels / (WHEEL_DIAMETER / 2);
  int degreesToTurnWheels = round(radToDeg(radiansToTurnWheels)); //if the robot doesn't turn properly, change this line

  Acquire(sharedDegreeMutex);
  sharedDegreesToTurn = degreesToTurnWheels;
  Release(sharedDegreeMutex);

  Acquire(rotationMutex);
  ResetTachoCount(OUT_A);
  ResetTachoCount(OUT_B);
  StartTask(turnWithMotorA);
  StartTask(turnWithMotorB);
}

task turnWithMotorA(){
  RotateMotor(OUT_A, MAX_MOTORPOWER, -(sharedDegreesToTurn));
  ExitTo(releaseMotors);
}
task turnWithMotorB(){
  RotateMotor(OUT_B, MAX_MOTORPOWER, (sharedDegreesToTurn));
  ExitTo(releaseMotors);
}
task releaseMotors(){
  Acquire(countMutex);
  if(releaseMotorCallCount == 0){ //If only one motor is done, increment
    releaseMotorCallCount++;
    Release(countMutex);
  }else{  //if both are done, release the mutex and reset count
    Release(rotationMutex);
    releaseMotorCallCount = 0;
    Release(countMutex);
  }
}

void driveStraight(float vectorUnitsToDrive){
  //This could be optimized more, but this is more readable

  float fullRotationsToDrive = ((vectorUnitsToDrive * CM_TO_VECTORUNIT) / WHEEL_CIRCUMFERENCE) / 10; //don't remove 10. for some reason it adds a factor 10 too much
  int degreesToDrive = round(DEGREES_PER_CIRCLE * fullRotationsToDrive);
  RotateMotor(OUT_AB, MAX_MOTORPOWER, degreesToDrive);
  RotateMotor(OUT_AB, 0, 0); //This is to block the currentMovementVector-update until the robot has driven the entire stretch
                             //Maybe it should just be remade, it isn't very pretty
  Acquire(moveVectorMutex);
    currentMovementVector.x = 0;
    currentMovementVector.y = 0;
  Release(moveVectorMutex);
}

float getRadiansToTurn(vec2 moveVector){

  vec2 straightAheadVector;
  straightAheadVector.x = 0;
  straightAheadVector.y = 1;

  float radsToRotate = vectorAngleBetween(straightAheadVector, moveVector);
  
  if(moveVector.x < 0){
    //vectorAngleBetween only returns the absolute value, but we need to know if we should turn left or right.
    //easiest way to check for this is to look at x value and update radsToRotate accordingly.
    radsToRotate = -radsToRotate;
  }

  return radsToRotate;
}
#endif
